---
// Optimized Blog Image Preloader Component
// This component implements efficient lazy loading without blocking page render

import { getCollection } from "astro:content";
import type { CollectionEntry } from "astro:content";

// Get all blog posts
const posts = await getCollection("blog");

// Extract hero images from blog posts - simplified approach
import { getImage } from "astro:assets";
import type { ImageMetadata } from "astro";

// Import all images from src/assets - but don't process them all at once
const allImages = import.meta.glob<{ default: ImageMetadata }>(
  "/src/assets/*.{jpeg,jpg,png,gif}"
);

// Only process images that are actually used in blog posts
// This prevents processing all images in the assets folder
const usedImagePaths = new Set<string>();
posts.forEach(post => {
  if (post.data.heroImage && typeof post.data.heroImage === 'string') {
    usedImagePaths.add(post.data.heroImage);
  }
});

// Create a lightweight map of blog post paths to image paths (not processed URLs)
const blogPostImageMap = new Map<string, string>();
posts.forEach(post => {
  if (post.data.heroImage && typeof post.data.heroImage === 'string') {
    blogPostImageMap.set(`/blog/${post.id}`, post.data.heroImage);
  }
});

// Only preload the main blog hero image for immediate visibility
// Other images will be loaded on-demand
let mainBlogImageUrl: string | null = null;
if (usedImagePaths.size > 0) {
  const firstImagePath = Array.from(usedImagePaths)[0];
  if (allImages[firstImagePath]) {
    try {
      const image = await getImage({ 
        src: allImages[firstImagePath](), 
        format: 'webp',
        quality: 80 // Reduced quality for faster loading
      });
      mainBlogImageUrl = image.src;
    } catch (error) {
      console.warn('Failed to process main blog image:', error);
    }
  }
}
---

<!-- Simplified preloader with minimal DOM overhead -->
<div class="blog-image-preloader" data-blog-posts={JSON.stringify(Array.from(blogPostImageMap.entries()))}>
  <!-- Only preload the main blog image immediately -->
  {mainBlogImageUrl && (
    <link rel="preload" href={mainBlogImageUrl} as="image" type="image/webp" />
  )}
</div>

<script>
  /**
   * Optimized Blog Image Preloader
   * 
   * Performance improvements:
   * - No blocking operations during page load
   * - Uses Intersection Observer for efficient lazy loading
   * - Minimal DOM queries and event listeners
   * - Progressive image loading strategy
   */

  class OptimizedBlogImagePreloader {
    private blogPostImageMap: Map<string, string> = new Map();
    private preloadedImages: Set<string> = new Set();
    private imageObserver: IntersectionObserver | null = null;
    private isInitialized = false;

    constructor() {
      // Parse the blog post data from the DOM
      const preloader = document.querySelector('.blog-image-preloader');
      if (!preloader) return;

      const data = preloader.getAttribute('data-blog-posts');
      if (!data) return;

      try {
        this.blogPostImageMap = new Map(JSON.parse(data));
      } catch (error) {
        console.warn('Failed to parse blog post data:', error);
        this.blogPostImageMap = new Map();
      }

      this.initialize();
    }

    private initialize() {
      if (this.isInitialized) return;
      this.isInitialized = true;

      // Use Intersection Observer for efficient lazy loading
      if ('IntersectionObserver' in window) {
        this.setupIntersectionObserver();
      } else {
        // Fallback for older browsers
        this.setupFallbackPreloading();
      }

      // Setup navigation-based preloading
      this.setupNavigationPreloading();
    }

    private setupIntersectionObserver() {
      // Create observer for blog post links
      this.imageObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const link = entry.target as HTMLAnchorElement;
              const href = link.getAttribute('href');
              if (href) {
                this.preloadBlogPostImage(href);
              }
            }
          });
        },
        {
          rootMargin: '100px', // Start loading 100px before element is visible
          threshold: 0.1
        }
      );

      // Observe all blog post links
      this.observeBlogPostLinks();
    }

    private setupFallbackPreloading() {
      // Simple hover-based preloading for older browsers
      document.addEventListener('mouseover', (event) => {
        const target = event.target as HTMLElement;
        if (target.tagName === 'A' && target.getAttribute('href')?.startsWith('/blog/')) {
          const href = target.getAttribute('href');
          if (href) {
            this.preloadBlogPostImage(href);
          }
        }
      });
    }

    private setupNavigationPreloading() {
      // Preload images when navigating to blog section
      const blogNavLink = document.querySelector('a[data-nav-link="/blog"]');
      if (blogNavLink) {
        blogNavLink.addEventListener('mouseenter', () => {
          // Preload first few blog post images
          const entries = Array.from(this.blogPostImageMap.entries()).slice(0, 3);
          entries.forEach(([path]) => {
            this.preloadBlogPostImage(path);
          });
        });
      }
    }

    private observeBlogPostLinks() {
      // Find all blog post links and observe them
      const blogLinks = document.querySelectorAll('a[href^="/blog/"]');
      blogLinks.forEach(link => {
        this.imageObserver?.observe(link);
      });

      // Also observe dynamically added links
      this.observeDynamicLinks();
    }

    private observeDynamicLinks() {
      // Use MutationObserver to watch for dynamically added blog links
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.addedNodes.forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node as Element;
              const blogLinks = element.querySelectorAll?.('a[href^="/blog/"]') || [];
              blogLinks.forEach(link => {
                this.imageObserver?.observe(link);
              });
            }
          });
        });
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
    }

    private async preloadBlogPostImage(path: string) {
      // Only preload once per session
      if (this.preloadedImages.has(path)) return;

      const imagePath = this.blogPostImageMap.get(path);
      if (!imagePath) return;

      try {
        // Create a lightweight image preload
        const img = new Image();
        img.onload = () => {
          this.preloadedImages.add(path);
        };
        img.onerror = () => {
          console.warn(`Failed to preload image for ${path}`);
        };
        
        // Set src to trigger loading
        img.src = imagePath;
      } catch (error) {
        console.warn(`Error preloading image for ${path}:`, error);
      }
    }

    public destroy() {
      if (this.imageObserver) {
        this.imageObserver.disconnect();
        this.imageObserver = null;
      }
      this.isInitialized = false;
    }
  }

  // Initialize the optimized preloader
  let preloader: OptimizedBlogImagePreloader | null = null;

  function initializePreloader() {
    if (preloader) {
      preloader.destroy();
    }
    preloader = new OptimizedBlogImagePreloader();
  }

  // Initialize on page load and page transitions
  document.addEventListener('DOMContentLoaded', initializePreloader);
  document.addEventListener('astro:page-load', initializePreloader);

  // Cleanup on page unload
  document.addEventListener('astro:before-preparation', () => {
    if (preloader) {
      preloader.destroy();
      preloader = null;
    }
  });
</script> 